// Generated by CoffeeScript 1.9.3
var BATCH_SIZE, FETCH_AT_ONCE_FOR_REINDEX, addBatch, async, base, batchCounter, batchInProgress, checkpointDocTypeRev, checkpointSeqNumber, cleanup, commonIndexFields, dataDirectory, db, dequeue, forgetDoc, indexQueue, indexdefinitions, indexdefinitionsID, indexer, locker, log, maybeReindexDocType, path, registerDefaultIndexes, reindexDocTypeAll, reindexDocTypeStep, status;

path = require('path');

dataDirectory = '/usr/local/var/cozy/data-system/';

if ((base = process.env).INDEXES_PATH == null) {
  base.INDEXES_PATH = path.join(dataDirectory, 'indexes');
}

indexer = require('cozy-indexer');

db = require('../helpers/db_connect_helper').db_connect();

async = require('async');

locker = require('../lib/locker');

log = require('printit')({
  date: true,
  prefix: 'indexer'
});

indexQueue = {};

batchInProgress = false;

BATCH_SIZE = 100;

batchCounter = 1;

indexdefinitions = {};

indexdefinitionsID = {};

status = {};

FETCH_AT_ONCE_FOR_REINDEX = BATCH_SIZE;

commonIndexFields = {
  "docType": {
    filter: true,
    searchable: false
  },
  "tags": {
    filter: true
  }
};

forgetDoc = locker.wrap('indexfile', indexer.forget);

addBatch = locker.wrap('indexfile', indexer.addBatch);

cleanup = locker.wrap('indexfile', indexer.cleanup);


/**
 * Initialize the indexer
 *
 * @return (callback) when initialization is complete
 */

exports.initialize = function(callback) {
  return async.waterfall([
    function(callback) {
      return indexer.store.open(callback);
    }, function(callback) {
      var query;
      query = {
        include_docs: true
      };
      return db.view("indexdefinition/all", query, function(err, rows) {
        var definitionDocument, docType, i, k, len, row, v;
        if (err) {
          return callback(err);
        }
        for (i = 0, len = rows.length; i < len; i++) {
          row = rows[i];
          docType = row.doc.targetDocType;
          definitionDocument = row.doc;
          for (k in commonIndexFields) {
            v = commonIndexFields[k];
            definitionDocument.ftsIndexedFields[k] = v;
          }
          indexdefinitions[docType] = definitionDocument;
          indexdefinitionsID[row.id] = docType;
          status[docType] = {
            total: 0,
            done: 0
          };
        }
        return registerDefaultIndexes(callback);
      });
    }, function(callback) {
      var docTypes;
      docTypes = Object.keys(indexdefinitions);
      return async.eachSeries(docTypes, maybeReindexDocType, callback);
    }, function(callback) {
      return indexer.store.get('indexedseq', function(err, seq) {
        return callback(err, seq);
      });
    }, function(seqno, callback) {
      var options;
      options = {
        include_docs: true,
        since: seqno
      };
      return db.changes(options, function(err, changes) {
        return callback(err, changes);
      });
    }, function(changes, callback) {
      var change, i, len;
      for (i = 0, len = changes.length; i < len; i++) {
        change = changes[i];
        if (!change.deleted) {
          exports.onDocumentUpdate(change.doc, change.seq);
        }
      }
      return callback(null);
    }
  ], callback);
};


/**
 * Get a batch from the queue and index it
 *
 */

dequeue = function() {
  var batchName, docType, docs, maxseqno, options;
  if (batchInProgress) {
    return null;
  }
  for (docType in indexQueue) {
    docs = indexQueue[docType];
    if (!(docs.length > 0)) {
      continue;
    }
    docs = docs.slice(0, BATCH_SIZE);
    indexQueue[docType] = docs.slice(BATCH_SIZE);
    batchInProgress = true;
    break;
  }
  if (!batchInProgress) {
    return null;
  }
  options = indexdefinitions[docType].ftsIndexedFields;
  maxseqno = docs[docs.length - 1]._seqno;
  batchName = "batch " + (batchCounter++);
  log.info("add " + batchName + " of " + docs.length + " " + docType);
  return addBatch(docs, options, function(err) {
    log.info(batchName + " done " + ((err != null ? err.stack : void 0) || 'success'));
    return checkpointSeqNumber(maxseqno, function(err) {
      if (err) {
        log.error("checkpoint error", err);
      }
      batchInProgress = false;
      status[docType].done += docs.length;
      return setImmediate(dequeue);
    });
  });
};


/**
 * Destroy the index completely (used for tests)
 *
 */

exports.cleanup = function(callback) {
  return cleanup(callback);
};


/**
 * To be called every time a document is updated
 * used in lib/feed
 *
 */

exports.onDocumentUpdate = function(doc, seqno) {
  var docType, ref;
  docType = (ref = doc.docType) != null ? typeof ref.toLowerCase === "function" ? ref.toLowerCase() : void 0 : void 0;
  if (docType in indexdefinitions) {
    doc._seqno = seqno;
    if (indexQueue[docType] == null) {
      indexQueue[docType] = [];
    }
    indexQueue[docType].push(doc);
    status[docType].total++;
    return setImmediate(dequeue);
  }
};


/**
 * To be called every time a document is deleted
 * used in lib/feed
 *
 */

exports.onDocumentDelete = function(doc, seqno) {
  var docType;
  if (doc.docType === 'indexdefinition') {
    docType = indexdefinitionsID[doc._id];
    return delete indexdefinitions[docType];
  } else if (doc.docType in indexdefinitions) {
    return forgetDoc(doc._id, function() {
      return log.info("doc" + doc._id + " unindexed");
    });
  }
};


/**
 * Perform a search in the index
 *
 * @params docType {array} docTypes to search in, empty for all
 * @params options {object} query options
 * @params options.query {mixed} the search terms
 * @params options.numPage {number} page number
 * @params options.pageSize {number} number of result by page
 * @params options.facets {object} see cozy-indexer doc
 * @params options.filter {object} see cozy-indexer doc
 *
 * @return (callback) {object} see cozy-indexer doc
 *
 */

exports.search = function(docTypes, options, callback) {
  var params;
  params = {
    offset: options.numPage || 0,
    pageSize: options.numByPage || 10
  };
  if (typeof options.query === 'string') {
    params.search = {
      "*": [options.query]
    };
  } else if (Array.isArray(options.query)) {
    params.search = {
      "*": options.query
    };
  } else {
    params.search = options.query;
  }
  if (options.facets) {
    params.facets = options.facets;
  }
  if (options.filter) {
    params.filter = options.filter;
  }
  if (docTypes.length > 0) {
    if (params.filter == null) {
      params.filter = {};
    }
    params.filter.docType = docTypes.map(function(t) {
      return [t, t];
    });
  }
  return indexer.search(params, callback);
};


/**
 * Register the indexdefintion for a docType
 *
 * @params docType {string} docType to register for
 * @params indexdefinition {object} a map of field to index rules
 *
 * @return (callback) after reindexing or 10s, whichever comes first
 *
 */

exports.registerIndexDefinition = function(docType, indexdefinition, callback) {
  var callbackOnce, changed, definitionDocument, existing, field, fieldDef, k, mergedFields, oldFieldDef, ref, v;
  callbackOnce = function(cause) {
    if (callback) {
      callback.apply(this, arguments);
    }
    return callback = null;
  };
  docType = docType.toLowerCase();
  existing = indexdefinitions[docType];
  changed = false;
  if (status[docType] == null) {
    status[docType] = {
      total: 0,
      done: 0
    };
  }
  if (existing) {
    mergedFields = {};
    ref = existing.ftsIndexedFields;
    for (k in ref) {
      v = ref[k];
      if (!commonIndexFields[k]) {
        mergedFields[k] = v;
      }
    }
    for (field in indexdefinition) {
      fieldDef = indexdefinition[field];
      oldFieldDef = existing.ftsIndexedFields[field];
      mergedFields[field] = indexer.mergeFieldDef(oldFieldDef, fieldDef);
      if (mergedFields[field] !== oldFieldDef) {
        changed = true;
      }
    }
    definitionDocument = existing;
    definitionDocument.ftsIndexedFields = mergedFields;
  } else {
    definitionDocument = {
      docType: "indexdefinition",
      ftsIndexedFields: indexdefinition,
      targetDocType: docType
    };
    changed = true;
  }
  if (changed) {
    return db.save(definitionDocument, function(err, savedDoc) {
      if (err) {
        return callback(err);
      }
      definitionDocument._id = savedDoc.id;
      definitionDocument._rev = savedDoc.rev;
      for (k in commonIndexFields) {
        v = commonIndexFields[k];
        definitionDocument.ftsIndexedFields[k] = v;
      }
      indexdefinitions[docType] = definitionDocument;
      indexdefinitionsID[savedDoc.id] = docType;
      setTimeout(callbackOnce.bind(null, new Error('timeout')), 10000);
      return reindexDocTypeAll(docType, function(err) {
        if (err) {
          return callbackOnce(err);
        }
        return checkpointDocTypeRev(docType, savedDoc.rev, callbackOnce);
      });
    });
  } else {
    log.info("rev is different, but definition not changed");
    return setImmediate(callbackOnce);
  }
};


/**
 * Store the indexdefintion rev within the index file
 *
 * @params docType {string} docType to register for
 * @params rev {string} value to store
 *
 * @return (callback) when done
 *
 */

checkpointDocTypeRev = function(docType, rev, callback) {
  return indexer.store.set("indexedrev/" + docType, rev, callback);
};


/**
 * Store the last indexed sequence number within the index file
 *
 * @params seqno {string} value to store
 *
 * @return (callback) when done
 *
 */

checkpointSeqNumber = function(seqno, callback) {
  return indexer.store.set('indexedseq', seqno, callback);
};


/**
 * Recursive function to reindex all docs for a given docType
 * get doc in batch of FETCH_AT_ONCE_FOR_REINDEX and add them immediately
 *
 * Note, this function doesn't use the indexQueue used for realtime events
 *
 * @params docType {string} value to store
 * @params definition {object} definition of fields to store
 *
 * @return (callback) when done
 *
 */

reindexDocTypeStep = function(docType, definition, callback, skip) {
  var query;
  if (skip == null) {
    skip = 0;
  }
  if (definition !== indexdefinitions[docType]) {
    log.info("aborting reindex");
    return callback(new Error('abort'));
  }
  query = {
    key: docType,
    limit: FETCH_AT_ONCE_FOR_REINDEX,
    skip: skip,
    include_docs: true,
    reduce: false
  };
  return db.view("doctypes/all", query, function(err, rows) {
    var docs;
    if (err) {
      return callback(err);
    }
    log.info("step " + docType + " " + skip + ", got " + rows.length + " docs");
    status[docType].total = rows.total_rows;
    if (rows.length === 0) {
      return callback(null);
    }
    docs = rows.toArray();
    return indexer.addBatch(docs, definition.ftsIndexedFields, function(err) {
      if (err) {
        return callback(err);
      }
      if (docs.length < FETCH_AT_ONCE_FOR_REINDEX) {
        return setImmediate(callback);
      } else {
        skip = skip + FETCH_AT_ONCE_FOR_REINDEX;
        return reindexDocTypeStep(docType, definition, callback, skip);
      }
    });
  });
};


/**
 * Reindex a given docType from the beginning
 *
 * @params docType {string} docType to reindex
 *
 * @return (callback) when done
 *
 */

reindexDocTypeAll = function(docType, callback) {
  return db.info(function(err, infos) {
    var definition, lastSeq;
    if (err) {
      return callback(err);
    }
    lastSeq = infos.update_seq;
    definition = indexdefinitions[docType];
    return reindexDocTypeStep(docType, definition, function(err) {
      if (err) {
        return callback(err);
      }
      return checkpointSeqNumber(lastSeq, callback);
    });
  });
};


/**
 * Check if given docType definition is the same we used to index it
 * if not, fire up a reindexing using reindexDocTypeAll
 *
 * @params docType {string} docType to test
 *
 * @return (callback) when done
 *
 */

maybeReindexDocType = function(docType, callback) {
  var definition;
  definition = indexdefinitions[docType];
  return indexer.store.get("indexedrev/" + docType, function(err, lastrev) {
    log.info("Check index revision for " + docType + "\n    in indexer:" + lastrev + " , in ds:" + definition._rev);
    if (!lastrev || lastrev !== definition._rev) {
      return reindexDocTypeAll(docType, function(err) {
        if (err) {
          return callback(err);
        }
        return checkpointDocTypeRev(docType, definition._rev, callback);
      });
    } else {
      return setImmediate(callback);
    }
  });
};


/**
 * [TMP] Register default indexes used by most cozy on October 2015,
 * ie. Folder, File and Note indexes.
 *
 * @return (callback) when done
 *
 */

registerDefaultIndexes = function(callback) {
  var actions, registerFile, registerFolder, registerNote;
  registerNote = function(done) {
    return exports.registerIndexDefinition('note', {
      title: {
        nGramLength: {
          gte: 1,
          lte: 2
        },
        stemming: true,
        weight: 5,
        fieldedSearch: false
      },
      content: {
        nGramLength: {
          gte: 1,
          lte: 2
        },
        stemming: true,
        weight: 1,
        fieldedSearch: false
      }
    }, done);
  };
  registerFile = function(done) {
    return exports.registerIndexDefinition('file', {
      name: {
        nGramLength: 1,
        stemming: true,
        weight: 1,
        fieldedSearch: false
      }
    }, done);
  };
  registerFolder = function(done) {
    return exports.registerIndexDefinition('folder', {
      name: {
        nGramLength: 1,
        stemming: true,
        weight: 1,
        fieldedSearch: false
      }
    }, done);
  };
  actions = [];
  if (!indexdefinitions.note) {
    actions.push(registerNote);
  }
  if (!indexdefinitions.file) {
    actions.push(registerFile);
  }
  if (!indexdefinitions.folder) {
    actions.push(registerFolder);
  }
  return async.series(actions, function(err) {
    return callback(err);
  });
};


/**
 * [TMP] Wait for a given document to be indexed
 *
 * Used in the former /data/index route
 * so apps tests wont break
 *
 */

exports.waitIndexing = function(id, callback) {
  var doc, docs, foundWaiting, i, len, tryAgain, type;
  foundWaiting = false;
  for (type in indexQueue) {
    docs = indexQueue[type];
    for (i = 0, len = docs.length; i < len; i++) {
      doc = docs[i];
      if (doc._id === id) {
        foundWaiting = true;
      }
    }
  }
  if (foundWaiting) {
    tryAgain = exports.waitIndexing.bind(null, id, callback);
    return setTimeout(tryAgain, 100);
  } else {
    return callback(null);
  }
};
